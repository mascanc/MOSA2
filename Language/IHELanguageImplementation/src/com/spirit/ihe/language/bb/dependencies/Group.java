package com.spirit.ihe.language.bb.dependencies;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.jgraph.graph.DefaultEdge;
import org.jgrapht.Graph;
import org.jgrapht.graph.DefaultDirectedGraph;

import com.spirit.ihe.language.bb.ABB;
import com.spirit.ihe.language.bb.SAT;


/**
 * This class implements the group() function. It takes as input a set of profiles,
 * and it provides the union of all the profiles and their dependencies.
 * @author max
 */
public class Group {

    /** This variable contains all the available ABB in the architecture. */
    private HashMap<String, ABB> availableAbbs;

    /** This variable contains the ABBs for which we evaluated the group and their dependencies. */
    private HashSet<ABB>         set = new HashSet<>();

    private HashSet<TFRule>      ruleList;

    /** The description of the ABB. */
    private String               abbdescription;

    /** The features of the ABB. */
    private String               abbfeature;

    /** The SGAM function. */
    private String               abbfunction;


    /**
     * Set the available ABBs to be located by the dependency function.
     * @param availableABBs
     */
    public void setAvailableABBs(HashMap<String, ABB> availableABBs) {
        this.availableAbbs = availableABBs;
    }

    public ABB group(ABB... abbs) {
        // firstly I group
        doGroup(abbs);
        // secondly I apply the new union
        Iterator<ABB> groupedAbbIterator = set.iterator();
        System.out.println("Assembling the ABB");
        String name = "";
        HashSet<Actor> actorList = new HashSet<>();
        HashSet<Transaction> transactionList = new HashSet<>();
        HashSet<Domain> domainList = new HashSet<>();
        HashSet<QualityAttribute> qualityAttributeList = new HashSet<>();
        HashSet<SecurityRequirement> securityRequirementList = new HashSet<>();
        ruleList = new HashSet<>();

        while (groupedAbbIterator.hasNext()) {
            ABB t = groupedAbbIterator.next();
            if (t != null) {
                name += "," + t.getName();
            } else {
                // This should be automatized. It happens when I have a TF Rule pointing to a profile which is not defined
                throw new NullPointerException("Unable to get a valid actor to group. Did you add all the actors in the SAT to match the rules?");
            }
            actorList.addAll(t.getActors());
            transactionList.addAll(t.getTransactions());
            domainList.addAll(t.getDomains());
            qualityAttributeList.addAll(t.getQualityAttributes()); // Here I have to call the evaluate?
            securityRequirementList.addAll(t.getSecurityRequirements());
            List<SAT> dependentSat = t.getParentSAT();
            for (SAT sat : dependentSat) {
                ruleList.addAll(sat.getOrchestration());
            }
        }

        // Create the new ABB

        if (abbdescription == null) {
            this.abbdescription = "Generated by Grouping, setter not called";
        }
        if (abbfeature == null) {
            this.abbfeature = "Generated by Grouping, setter on feature not called";
        }
        if (getAbbfunction() == null) {
            this.setAbbfunction("Generated by Grouping, setter on a function not called");
        }
        ABB n = new ABB(name.substring(1, name.length()), abbdescription, abbfeature, getAbbfunction());
        n.getActors().addAll(actorList);
        n.getTransactions().addAll(transactionList);
        n.getDomains().addAll(domainList);
        n.getQualityAttributes().addAll(qualityAttributeList);
        n.getSecurityRequirements().addAll(securityRequirementList);
        return n;

    }

    /**
     * Since the rule list belongs to the SAT, they can't be returned in the ABB,
     * so the caller shall know to which SAT the rules should be set.
     * @return
     */
    public HashSet<TFRule> getRuleList() {
        return this.ruleList;
    }

    private void doGroup(ABB... abbs) {
        /*
         * Two steps approach: first I get the dependencies,
         * secondly I apply the grouping recursively to
         * each abb and their dependencies.
         */

        // find dependencies. 


        for (ABB abb : abbs) {
            if (set.contains(abb)) {
                return;
            }
            System.out.println("GROUP: adding " + abb);
            set.add(abb);
            System.out.println("GROUP: resolving dependency");
            ResolveDependency rd = new ResolveDependency(availableAbbs);
            HashSet<ABB> back = rd.resolve(abb); 
            if (back != null) {
                // back contains the dependencies of the ABB. 
                // for each dependency I apply the group

                System.out.println("GROUP: resolved " + back.size() + " dependencies");

                set.addAll(back);

                Iterator<ABB> dependencyIterator = back.iterator();
                while (dependencyIterator.hasNext()) {
                    ABB y = dependencyIterator.next();
                    System.out.println("Resolved dependency " + y + " for ABB " + abb);
                    System.out.println("Evaluating quality attributes");
                    abb.getQualityAttributes().stream().forEach(x -> x.evaluate(abb, y));

                    System.out.println("Recursively calling group(" + abb.getName() + "," + y.getName() + ")");
                    doGroup(abb, y);
                }
            } else {
                System.out.println("GROUP: no dependencies resolved");
            }




        }


    }

    /**
     * Here I create the directed graph. The TF rule says that there is a dependency from
     * left to right. So the vertex are all actors.
     * @param groupedABB
     * @param ruleList2
     * @return
     */
    public Graph<String, DefaultEdge> createGraph(ABB groupedABB, HashSet<TFRule> ruleList2) {
        Graph<String, DefaultEdge> g = new DefaultDirectedGraph<>(DefaultEdge.class);

        ruleList2.stream().forEach(x -> {
            /*
             * Ok the rule tells me that there is a depedendency from the right actor to the left profile to the right profile.
             * and from the left actor to the left profile, and from the right actor to the right profile
             */
            String ra = x.getRightActor();
            String rabb = x.getRightABB();
            String la = x.getLeftActor();
            String labb = x.getLeftABB();
            g.addVertex(labb);
            g.addVertex(la);
            g.addVertex(ra);
            g.addVertex(rabb);
            g.addEdge(ra, rabb);
            g.addEdge(la, labb);
            g.addEdge(labb, rabb);

        });



        return g;
    }

    /**
     * @return the abbdescription
     */
    public String getAbbdescription() {
        return abbdescription;
    }

    /**
     * @param abbdescription
     *            the abbdescription to set
     */
    public void setAbbdescription(String abbdescription) {
        this.abbdescription = abbdescription;
    }

    /**
     * @return the abbfeature
     */
    public String getAbbfeature() {
        return abbfeature;
    }

    /**
     * @param abbfeature
     *            the abbfeature to set
     */
    public void setAbbfeature(String abbfeature) {
        this.abbfeature = abbfeature;
    }

    public String getAbbfunction() {
        return abbfunction;
    }

    public void setAbbfunction(String abbfunction) {
        this.abbfunction = abbfunction;
    }



}
